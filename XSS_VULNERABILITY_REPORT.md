# XSS Vulnerability Report
**Date:** December 2024
**Codebase:** NextJS_Contentful Portfolio
**Severity Levels:** Critical, High, Medium, Low, Informational

---

## Executive Summary

This report documents the findings of a comprehensive Cross-Site Scripting (XSS) vulnerability assessment of the NextJS_Contentful portfolio application. The codebase demonstrates good security practices with proper HTML escaping, URL validation, and sanitization utilities in place. However, several potential vulnerabilities and areas for improvement have been identified.

**Overall Security Posture:** Good with some areas requiring attention.

**Key Findings:**
- ✅ No use of `dangerouslySetInnerHTML`, `innerHTML`, or `eval()` found
- ✅ Proper HTML escaping implemented and used throughout
- ✅ URL validation functions in place
- ⚠️ Contentful rich text rendering lacks handlers for hyperlinks and lists
- ⚠️ Content Security Policy includes `unsafe-eval` and `unsafe-inline` (necessary for Next.js/Flowbite but reduces security)
- ⚠️ Empty href attribute in contact buttons component

---

## 1. HIGH VULNERABILITIES

### 1.1 Contentful Rich Text Rendering - Missing Hyperlink and List Handlers

**Location:** `src/app/utilities/sanitize.tsx:7-35`

**Code:**
```tsx
export function sanitizeContentfulRichText(content: Document): React.ReactNode {
  const options: Options = {
    renderNode: {
      [BLOCKS.PARAGRAPH]: (node, children) => <p>{children}</p>,
      [BLOCKS.HEADING_1]: (node, children) => <h1>{children}</h1>,
      [BLOCKS.HEADING_2]: (node, children) => <h2>{children}</h2>,
      [BLOCKS.HEADING_3]: (node, children) => <h3>{children}</h3>,
      // Explicitly define allowed nodes only
    },
    renderMark: {
      [MARKS.BOLD]: (text) => <strong>{text}</strong>,
      [MARKS.ITALIC]: (text) => <em>{text}</em>,
      // Explicitly define allowed marks only
    },
    // ...
  };
  return documentToReactComponents(content, options);
}
```

**Issue:** The sanitization function handles paragraphs and headings but does not explicitly handle:
- Hyperlinks (`BLOCKS.HYPERLINK` or `INLINES.HYPERLINK`)
- Lists (`BLOCKS.UL_LIST`, `BLOCKS.OL_LIST`, `BLOCKS.LIST_ITEM`)
- Other potential content types

If Contentful content contains hyperlinks or lists, they may be rendered by the default renderer without proper URL validation, potentially allowing malicious `javascript:` or `data:` URLs.

**Risk:**
- **Severity:** High
- **Impact:** If Contentful content contains hyperlinks with malicious URLs, they could be rendered without validation, leading to XSS
- **Exploitability:** Medium (requires Contentful to contain hyperlinks with malicious URLs)

**Recommendation:**
1. Explicitly handle hyperlinks with URL validation
2. Add handlers for lists if they're expected in Contentful content
3. Add a default handler that safely escapes or ignores unhandled nodes
4. Log warnings when unhandled content types are encountered

**Fix Example:**
```tsx
import { INLINES } from "@contentful/rich-text-types";
import { isValidUrl } from "./sanitize";

export function sanitizeContentfulRichText(content: Document): React.ReactNode {
  const options: Options = {
    renderNode: {
      [BLOCKS.PARAGRAPH]: (node, children) => <p>{children}</p>,
      [BLOCKS.HEADING_1]: (node, children) => <h1>{children}</h1>,
      [BLOCKS.HEADING_2]: (node, children) => <h2>{children}</h2>,
      [BLOCKS.HEADING_3]: (node, children) => <h3>{children}</h3>,
      [BLOCKS.UL_LIST]: (node, children) => <ul>{children}</ul>,
      [BLOCKS.OL_LIST]: (node, children) => <ol>{children}</ol>,
      [BLOCKS.LIST_ITEM]: (node, children) => <li>{children}</li>,
      [INLINES.HYPERLINK]: (node, children) => {
        const url = node.data.uri;
        if (isValidUrl(url)) {
          return (
            <a href={url} target="_blank" rel="noopener noreferrer">
              {children}
            </a>
          );
        }
        console.warn('Invalid URL in hyperlink:', url);
        return <span>{children}</span>;
      },
      // Default handler for unhandled nodes
      default: (node, children) => {
        console.warn('Unhandled content type:', node.nodeType);
        return <>{children}</>;
      },
    },
    renderMark: {
      [MARKS.BOLD]: (text) => <strong>{text}</strong>,
      [MARKS.ITALIC]: (text) => <em>{text}</em>,
    },
    renderText: (text) => {
      return text
        .split("\n")
        .reduce<React.ReactNode[]>((children, textSegment, index) => {
          if (index === 0) {
            return [textSegment];
          } else {
            return [...children, <br key={index} />, textSegment];
          }
        }, []);
    },
  };

  return documentToReactComponents(content, options);
}
```

---

### 1.2 Empty href Attribute in Contact Buttons

**Location:** `src/app/components/contactButtons.tsx:28`

**Code:**
```tsx
{
  href: "",
  text: "linkedin.com/in/paul-stroot",
  icon: <LinkedIn />,
},
```

**Issue:** One of the contact buttons has an empty `href` attribute. While this doesn't directly cause XSS, it's a security best practice issue. An empty href could potentially be exploited if the component logic changes or if it's used as a template for user-generated content.

**Risk:**
- **Severity:** Low-Medium (could be High if component is reused for user content)
- **Impact:** Potential for unexpected behavior or future vulnerabilities
- **Exploitability:** Low

**Recommendation:**
1. Either provide a valid URL or remove the link entirely
2. Add validation to ensure all hrefs are non-empty before rendering
3. Consider using a disabled state or different component for non-linkable items

**Fix Example:**
```tsx
{
  href: "https://linkedin.com/in/paul-stroot", // Add actual URL
  text: "linkedin.com/in/paul-stroot",
  icon: <LinkedIn />,
},
// OR if it shouldn't be a link:
{links().filter(link => link.href).map((link, i) => (
  // Only render links with valid hrefs
))}
```

---

## 2. MEDIUM VULNERABILITIES

### 2.1 URL Validation in Project Links - Potential Protocol Bypass

**Location:** `src/app/projects/[slug]/components/ProjectCarousel.tsx:144-154`

**Code:**
```tsx
{activeProject.fields.url && isValidUrl(activeProject.fields.url) && (
  <ModalFooter className="flex flex-col items-end py-2 ">
    <Link
      href={activeProject.fields.url}
      target="_blank"
      rel="noopener noreferrer"
    >
      <Button className="btn btn-sm btn-accent">Live Site</Button>
    </Link>
  </ModalFooter>
)}
```

**Issue:** While `isValidUrl()` checks for protocol validation and prevents `javascript:` protocol, the URL is still used directly in the `href` attribute. If Contentful is compromised or if there's a bypass in the validation logic, malicious URLs could be injected. Additionally, Next.js Link component may have its own URL validation, but relying solely on client-side validation is risky.

**Risk:**
- **Severity:** Medium (could be High if Contentful is compromised)
- **Impact:** Potential for protocol-based XSS (e.g., `javascript:`, `data:`, `vbscript:`) if validation is bypassed
- **Exploitability:** Low-Medium (requires Contentful compromise or validation bypass)

**Recommendation:**
1. Add server-side validation when fetching Contentful data
2. Consider using a Content Security Policy (CSP) to prevent protocol-based XSS
3. Add additional validation to ensure URLs are from trusted domains (if applicable)
4. Consider using a URL sanitization library for additional protection

**Current Implementation Status:** ✅ `rel="noopener noreferrer"` is already present, which is good.

---

### 2.2 Content Security Policy - Unsafe Directives

**Location:**
- `src/middleware.ts:19-27`
- `next.config.ts:29-37`

**Code:**
```tsx
const csp = [
  "default-src 'self'",
  "script-src 'self' 'unsafe-eval' 'unsafe-inline'", // 'unsafe-eval' for Next.js dev, 'unsafe-inline' for Flowbite theme script
  "style-src 'self' 'unsafe-inline'", // 'unsafe-inline' for Tailwind CSS and Flowbite
  "img-src 'self' data: https://images.ctfassets.net", // Contentful images
  "font-src 'self' data:",
  "connect-src 'self' https://api.smtp2go.com", // SMTP2GO API for contact form
  "frame-ancestors 'none'",
].join("; ");
```

**Issue:** The CSP includes `'unsafe-eval'` and `'unsafe-inline'` for scripts and styles. While these may be necessary for Next.js development and Flowbite/Tailwind CSS, they significantly reduce the effectiveness of CSP in preventing XSS attacks.

**Risk:**
- **Severity:** Medium
- **Impact:** CSP provides less protection against XSS attacks
- **Exploitability:** Low (but if XSS occurs, CSP won't prevent it)

**Recommendation:**
1. Use nonces or hashes for inline scripts in production
2. Consider using a stricter CSP in production vs development
3. Evaluate if Flowbite theme switching can be done without inline scripts
4. Use build-time CSS extraction to minimize inline styles

**Note:** This is a trade-off between security and functionality. The current implementation is acceptable if the benefits outweigh the risks, but should be documented and reviewed periodically.

---

### 2.3 Image URL Sanitization - Protocol-Relative URL Risk

**Location:** Multiple files using `sanitizeImageUrl()`:
- `src/app/projects/[slug]/components/ProjectCard.tsx:59, 76, 88`
- `src/app/projects/[slug]/components/ProjectCarousel.tsx:105, 119`
- `src/app/projects/[slug]/page.tsx:96`
- `src/app/components/skills.tsx:72`

**Code:**
```tsx
export const sanitizeImageUrl = (url: string): string => {
  // Ensure URL is from Contentful CDN or is a relative path
  if (url.startsWith("//")) {
    return `https:${url}`;
  }
  if (url.startsWith("http://") || url.startsWith("https://")) {
    // Validate it's from Contentful CDN
    if (!url.includes("contentful.com") && !url.includes("ctfassets.net")) {
      throw new Error("Invalid image source");
    }
    return url;
  }
  // Relative path from Contentful
  return `https:${url}`;
};
```

**Issue:** The function handles protocol-relative URLs (`//example.com`) by prepending `https:`, but if Contentful is compromised and returns a protocol-relative URL pointing to a malicious domain, this could lead to loading images from untrusted sources. While the function validates full URLs, protocol-relative URLs are only checked for the `//` prefix, not the domain.

**Risk:**
- **Severity:** Medium
- **Impact:** Potential for loading malicious resources if Contentful is compromised
- **Exploitability:** Low (requires Contentful compromise)

**Recommendation:**
1. Validate that protocol-relative URLs are from Contentful CDN domains
2. Consider rejecting protocol-relative URLs entirely if they're not expected
3. Add domain validation for protocol-relative URLs

**Fix Example:**
```tsx
export const sanitizeImageUrl = (url: string): string => {
  if (url.startsWith("//")) {
    // Validate protocol-relative URLs are from Contentful
    if (!url.includes("//images.ctfassets.net") && !url.includes("//contentful.com")) {
      throw new Error("Invalid image source: protocol-relative URL must be from Contentful");
    }
    return `https:${url}`;
  }
  if (url.startsWith("http://") || url.startsWith("https://")) {
    if (!url.includes("contentful.com") && !url.includes("ctfassets.net")) {
      throw new Error("Invalid image source");
    }
    return url;
  }
  // Relative path from Contentful - validate it doesn't contain protocol
  if (url.includes("://")) {
    throw new Error("Invalid image source: relative URL contains protocol");
  }
  return `https:${url}`;
};
```

---

## 3. LOW VULNERABILITIES / BEST PRACTICES

### 3.1 Contact Form API - HTML Email Sanitization

**Location:** `src/app/api/contact/route.ts:115-124`

**Code:**
```tsx
// If HTML is provided, it should be sanitized with a proper HTML sanitizer
// For now, we'll reject HTML emails or require proper sanitization
// In production, consider using DOMPurify or similar
let sanitizedHtml: string | undefined;
if (body.html) {
  // WARNING: HTML emails are a security risk if not properly sanitized
  // For now, we'll escape it as plain text to be safe
  // In production, use a proper HTML sanitizer like DOMPurify
  sanitizedHtml = escapeHtml(String(body.html).trim());
}
```

**Issue:** The API currently escapes HTML emails as plain text, which is safe but not ideal if HTML emails are needed. The code includes a warning comment but doesn't use a proper HTML sanitizer.

**Risk:**
- **Severity:** Low
- **Impact:** If HTML emails are enabled in the future without proper sanitization, could lead to email-based XSS
- **Exploitability:** Low (HTML emails are currently escaped)

**Recommendation:**
1. If HTML emails are needed, implement DOMPurify or similar library
2. Consider rejecting HTML emails entirely if not needed
3. Document the decision in code comments

**Current Status:** ✅ HTML is currently escaped, which is safe. The warning comment is appropriate.

---

### 3.2 Metadata Generation - Proper Escaping

**Location:** `src/app/projects/[slug]/page.tsx:72-76`

**Code:**
```tsx
return {
  title: `${escapeHtml(activeProject.fields.title)} | Paul Stroot`,
  description: escapeHtml(
    documentToPlainTextString(activeProject.fields.summary).substring(0, 160)
  ),
};
```

**Status:** ✅ **FIXED** - The metadata now uses proper `escapeHtml()` function instead of regex replacement. This is correct.

---

### 3.3 URL Display Function - Error Handling

**Location:** `src/app/utilities/sanitize.tsx:37-49`

**Code:**
```tsx
export const sanitizeUrlForDisplay = (url: string): string => {
  try {
    const parsed = new URL(url);
    // Only allow http/https protocols for display
    if (parsed.protocol !== "http:" && parsed.protocol !== "https:") {
      return "Invalid URL";
    }
    return parsed.hostname + parsed.pathname; // Display only safe parts
  } catch {
    console.warn("Failed to parse URL for display:", url);
    return "Invalid URL"; // Safe default instead of original URL
  }
};
```

**Status:** ✅ **FIXED** - The function now returns a safe default instead of the original URL on parse failure. This is correct.

---

## 4. POSITIVE SECURITY PRACTICES IDENTIFIED

### 4.1 Proper HTML Escaping
- ✅ `escapeHtml()` function is properly implemented and used throughout the codebase
- ✅ User input in contact form is escaped before sending to API
- ✅ Contentful titles and names are properly escaped when rendered
- ✅ Error messages are escaped before display

### 4.2 URL Validation
- ✅ `isValidUrl()` function properly validates URLs and prevents `javascript:` protocol
- ✅ `sanitizeImageUrl()` function validates image URLs are from Contentful CDN
- ✅ Slug validation with regex prevents injection in URLs
- ✅ External links use `rel="noopener noreferrer"`

### 4.3 React Best Practices
- ✅ No use of `dangerouslySetInnerHTML` found
- ✅ No use of `innerHTML` found
- ✅ No use of `eval()` found
- ✅ Proper use of React's built-in escaping
- ✅ Next.js Image component used with domain whitelist

### 4.4 API Security
- ✅ Input validation implemented in contact API route
- ✅ Email format validation
- ✅ Length limits on input fields
- ✅ Error messages don't expose internal details
- ✅ All text fields are escaped before use

### 4.5 Contentful Rich Text Sanitization
- ✅ Custom sanitization function restricts allowed content types
- ✅ Uses Contentful's official rich text renderer
- ✅ Explicit handlers for paragraphs and headings
- ✅ Text rendering properly handles newlines

### 4.6 Security Headers
- ✅ Content Security Policy implemented
- ✅ X-Frame-Options set to DENY
- ✅ X-Content-Type-Options set to nosniff
- ✅ Referrer-Policy configured
- ✅ Permissions-Policy configured

---

## 5. RECOMMENDATIONS SUMMARY

### Immediate Actions (High Priority)
1. **Add hyperlink handler to `sanitizeContentfulRichText()`** with URL validation
2. **Add list handlers** (UL_LIST, OL_LIST, LIST_ITEM) if lists are expected in Contentful content
3. **Fix empty href** in contact buttons component
4. **Add default handler** for unhandled Contentful content types

### Short-term Improvements (Medium Priority)
1. **Improve protocol-relative URL validation** in `sanitizeImageUrl()`
2. **Add server-side URL validation** when fetching Contentful data
3. **Consider stricter CSP** in production (use nonces/hashes instead of unsafe-inline)
4. **Add logging/monitoring** for unhandled content types and invalid URLs

### Long-term Enhancements (Low Priority)
1. **Implement DOMPurify** for HTML email sanitization if HTML emails are needed
2. **Add security monitoring** and alerting for suspicious activities
3. **Regular security audits** of Contentful content
4. **Consider implementing Subresource Integrity (SRI)** for external resources
5. **Add automated security testing** to CI/CD pipeline

---

## 6. TESTING RECOMMENDATIONS

### Manual Testing
1. Test with malicious Contentful content (if possible in a test environment):
   - Hyperlinks with `javascript:` protocol
   - Hyperlinks with `data:` protocol
   - Protocol-relative URLs in images
   - Unhandled content types (lists, embedded entries)
2. Test URL validation with various protocol schemes
3. Test contact form with XSS payloads
4. Test metadata generation with HTML content
5. Test empty/invalid URLs in various contexts

### Automated Testing
1. Add unit tests for all sanitization functions:
   - `escapeHtml()` with various XSS payloads
   - `isValidUrl()` with malicious protocols
   - `sanitizeImageUrl()` with protocol-relative URLs
   - `sanitizeContentfulRichText()` with hyperlinks and lists
2. Add integration tests for API routes with malicious input
3. Use security scanning tools (e.g., OWASP ZAP, Snyk, npm audit)
4. Implement security regression tests
5. Add tests for CSP violations

### Contentful Content Review
1. Audit existing Contentful content for:
   - Hyperlinks with external URLs
   - Protocol-relative URLs
   - Unusual content types
2. Set up Contentful webhooks to monitor content changes
3. Consider content validation rules in Contentful

---

## 7. REFERENCES

- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)
- [Next.js Security Best Practices](https://nextjs.org/docs/app/building-your-application/configuring/content-security-policy)
- [Contentful Rich Text Rendering](https://www.contentful.com/developers/docs/javascript/tutorials/rendering-contentful-rich-text-with-javascript/)
- [React Security Best Practices](https://react.dev/learn/escape-hatches)
- [Content Security Policy (CSP) Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)
- [DOMPurify - HTML Sanitizer](https://github.com/cure53/DOMPurify)

---

## Appendix: Code Locations Summary

| Severity | Location | Issue | Status |
|----------|----------|-------|--------|
| High | `sanitize.tsx:7-35` | Missing hyperlink/list handlers in rich text | ⚠️ Needs Fix |
| High | `contactButtons.tsx:28` | Empty href attribute | ⚠️ Needs Fix |
| Medium | `ProjectCarousel.tsx:144-154` | URL validation could be improved | ✅ Has rel="noopener" |
| Medium | `middleware.ts:19-27` | CSP includes unsafe directives | ⚠️ Trade-off |
| Medium | `sanitize.tsx:82-96` | Protocol-relative URL validation | ⚠️ Could be improved |
| Low | `route.ts:115-124` | HTML email sanitization | ✅ Currently safe |
| Low | `page.tsx:72-76` | Metadata escaping | ✅ Fixed |
| Low | `sanitize.tsx:37-49` | URL display fallback | ✅ Fixed |

---

## Changelog

**December 2024:**
- Updated report to reflect current codebase state
- Noted improvements: metadata escaping, URL display fallback, image URL sanitization
- Identified new issues: missing hyperlink handlers, empty href
- Updated recommendations based on current implementation

---

**Report Generated:** Automated Security Audit
**Next Review Date:** Recommended in 3-6 months or after major changes
**Last Updated:** December 2024
